import atexit
import os
import shutil
import streamlit as st
from glob import glob
import base64

# Terminate Process when the UI is closed
def handle_exit():
    print("Streamlit UI is closed. Exiting the test runner....")
    import atexit
import os
import shutil
import streamlit as st
from glob import glob
import base64
import re  # Import the regular expression module


# Terminate Process when the UI is closed
def handle_exit():
    print("Streamlit UI is closed. Exiting the test runner....")
    os._exit(0)


def open_excel_file(file_path):
    try:
        os.startfile(file_path)  # For Windows
    except AttributeError:
        try:
            import subprocess
            subprocess.run(['open', file_path])  # For macOS
        except:
            st.error(f"Failed to open file.  Please open manually: {file_path}")
    except Exception as e:
        st.error(f"Failed to open file: {e}")



def get_latest_report(results_dir="results", static_dir="static"):
    report_files = glob(os.path.join(results_dir, "test_report_*.html"))
    return max(report_files, key=os.path.getctime) if report_files else None


def show_latest_report(results_dir="results", static_dir="static"):
    report_file = get_latest_report(results_dir)

    if not report_file:
        st.warning("No Report Found")
        return

    latest_report = report_file
    report_filename = os.path.basename(latest_report)

    # Read the file content
    with open(latest_report, "r", encoding="utf-8") as f:  # Open as text
        report_content = f.read()

    # Embed CSS and JavaScript (simplified for demonstration)
    # IMPORTANT:  This is a simplified example.  For a real report, you would
    # need to:
    # 1.  Locate the actual CSS and JS files used by your report.
    # 2.  Read their content.
    # 3.  Embed the content within <style> and <script> tags in the HTML.
    # 4.  Handle any font files or other assets.  For fonts, you'd likely need to
    #     base64-encode them and include them in the CSS.
    #
    #  This example assumes very basic CSS/JS within the HTML or that you can easily
    #  extract it.  For complex reports, you'll need more robust parsing.

    #  Simplified example:  Let's assume the report has inline styles and a simple script.
    #  You'd need to adapt this to your report's structure.
    report_content = re.sub(r'<link rel="stylesheet".*?>', '', report_content)
    report_content = re.sub(r'<script .*?</script>', '', report_content)


    # Encode the modified HTML
    report_base64 = base64.b64encode(report_content.encode('utf-8')).decode()

    # Use st.markdown with an anchor tag and a JavaScript function
    st.markdown(
        f"""
        <a id="download-link" href="#" download="{report_filename}">Click Here to Download Report</a>
        <script>
        document.getElementById('download-link').addEventListener('click', function(event) {{
            event.preventDefault(); // Prevent the default link behavior
            var base64Data = '{report_base64}';
            var blob = b64toBlob(base64Data, 'text/html;charset=utf-8'); // Specify charset
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = '{report_filename}';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }});

        // Function to convert base64 to Blob
        function b64toBlob(b64Data, contentType='', sliceSize=512) {{
            const byteCharacters = atob(b64Data);
            const byteArrays = [];

            for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {{
            const slice = byteCharacters.slice(offset, offset + sliceSize);

            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {{
                byteNumbers[i] = slice.charCodeAt(i);
            }}

            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
            }}

            const blob = new Blob(byteArrays, {{type: contentType}});
            return blob;
        }}
        </script>
        """,
        unsafe_allow_html=True,
    )



def streamlit_runner():
    st.set_page_config(page_title="GPS Test Automation", layout="centered")
    st.title("Bulk Alerts Test Automation")
    st.write("")
    atexit.register(handle_exit)

    coll, col_gap, col2 = st.columns([1, 8.1, 1])

    with coll:
        # Run Test when button is clicked
        if st.button("Run Test"):
            # st.empty()
            with st.spinner("Test Execution is In Progress...."):
                from UI.test_runner import run_tests # Import run_tests
                status, results = run_tests()
                st.session_state["test_status"] = status
                st.session_state["report_path"] = get_latest_report()

            if "test_status" in st.session_state:
                status = st.session_state["test_status"]
                report = st.session_state.get("report_path")
                if status == "PASSED":
                    st.success("Test Execution Completed and Test 'PASSED'!!!")
                else:
                    st.error("Test Execution Completed and Some Test 'FAILED'")

                st.markdown("---")
                if report and os.path.exists(report):
                    # Use the show_latest_report function
                    show_latest_report()
                else:
                    st.warning("No report found. Run the test to generate it.")

    with col2:
        excel_path = os.path.join("resources", "data file", "data.xlsx")
        if os.path.exists(excel_path):
            st.empty()
            if st.button("Update Data Sheet"):
                open_excel_file(excel_path)
        else:
            st.error("File not found: resources/data_file/data.xlsx")



if __name__ == "__main__":
    streamlit_runner()
